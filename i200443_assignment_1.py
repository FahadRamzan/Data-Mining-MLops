# -*- coding: utf-8 -*-
"""i200443_Assignment_1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PVdKfpPTCFkOc-9rGB3FfB22VmniINTO
"""

#Immporting Libraries That Will Be Used In The Project

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
from sklearn.preprocessing import LabelEncoder
from sklearn.cluster import AgglomerativeClustering
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.cluster import KMeans
from sklearn.metrics import silhouette_score
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import cross_val_score
from sklearn.metrics import mean_absolute_error, mean_squared_error

#Reading Dataset
df = pd.read_csv('healthcare_dataset.csv')

#printing out first 10 rows of the dataset
df.head(10)

#Prining Shape
df.shape

#Printing data types
df.dtypes

#Checking Null Count in every feature
df.isnull().sum()

df.describe()

#date of admisson is an object, we need to convert it to datetime
df['Date of Admission'] = pd.to_datetime(df['Date of Admission'])

#date of discharge is an object, we need to convert it to datetime
df['Discharge Date'] = pd.to_datetime(df['Discharge Date'])

df.info()

#Checking for duplicates
df.duplicated().sum()

#Printing Type of Features weather they are ordinal or nominal or categorical
for col in df.columns:
    print(col, ':', len(df[col].unique()), 'labels')

#Checking for unique values in the dataset
df.nunique()

#Print blood Type is nominal
print("Name is Nominal")
print("Age is continous")
print("Gender is Binary")
print("Blood Type is Nominal")
print("Medical Condition is Nominal")
print("Date of Admisson is Continous")
print("Room Number is Continous")
print("Admisson Type is Ordinal")
print("Discharge Date is Continous")
print("Medication is nominal")
print("Test Result is Ordinal")
print ("Hospital is Continous")
print("Inssurance Provider is Continous")
print("Doctor is Nominal")

df['Date of Admission'] = pd.to_datetime(df['Date of Admission'])
df['Discharge Date'] = pd.to_datetime(df['Discharge Date'])

#Checking if discharge date in earlier than admission date.
miss_match_dates = df['Discharge Date'] < df['Date of Admission']
df_miss = df[miss_match_dates]
df_miss
miss_match_dates_count = (df['Discharge Date'] < df['Date of Admission']).sum()
print(miss_match_dates_count)

#make a new feature in dataset by calculating the number of days a patient stayed in the hospital
df['Duration'] = df['Discharge Date'] - df['Date of Admission']
df['Duration'] = df['Duration'].dt.days
df['Duration']

#printing out first 10 rows of the dataset
df.head(10)

#Label Encoding for Admisson type

from sklearn.preprocessing import LabelEncoder
labelencoder = LabelEncoder()
df['Admission Type'] = labelencoder.fit_transform(df['Admission Type'])
df['Admission Type']

#printing out first 10 rows of the dataset
df.head(10)

#EDA on Age
sns.histplot(df['Age'], kde=True)
plt.title('Age Distribution')
plt.show()

#data analysis for age
sns.boxplot(x='Age', data=df)
plt.title('Age Distribution')
plt.show()

#Calculating summary statstics.

age = df['Age']
age.describe()

#pie chart on gender distribution
gender_counts = df['Gender'].value_counts()
gender_counts.plot.pie(autopct='%1.1f%%', startangle=90)
plt.axis('equal')
plt.title("Gender Distribution")
plt.show()

#pie chart on admisson type
#label 0 as elective
#label 1 as emergency
#label 2 as newborn
admission_type_counts = df['Admission Type'].value_counts()
admission_type_counts.plot.pie(autopct='%1.1f%%', startangle=90)
plt.axis('equal')

#pie chart on blood type
blood_type_counts = df['Blood Type'].value_counts()
blood_type_counts.plot.pie(autopct='%1.1f%%', startangle=90)
plt.axis('equal')
plt.title("Blood Type Distribution")

#make pie chart for medical condition
medical_condition_counts = df['Medical Condition'].value_counts()
medical_condition_counts.plot.pie(autopct='%1.1f%%', startangle=90)
plt.axis('equal')
plt.title("Medical Condition Distribution")

count_medical_conditions = (df['Medical Condition']).value_counts()
plt.figure(figsize=(6, 4))
count_medical_conditions.plot(kind='bar', color='black')
plt.xlabel('Medical Condition')
plt.ylabel('Count')
plt.title('Count of Medical Conditions')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

#count of medical condition with respect to blood groups
medical_condition_blood_type = pd.crosstab(df['Medical Condition'], df['Blood Type'])
medical_condition_blood_type.plot(kind='bar', stacked=True)
plt.title('Medical Condition with respect to Blood Type')
plt.xlabel('Medical Condition')
plt.ylabel('Count')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

#medical condition with duration
medical_condition_duration = df.groupby('Medical Condition')['Duration'].mean()
medical_condition_duration.plot(kind='bar', color='blue')
plt.xlabel('Medical Condition')
plt.ylabel('Duration')
plt.title('Medical Condition with Duration')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

#line graph to show trend of how duration varies with age
age_duration = df.groupby('Age')['Duration'].mean()
age_duration.plot(kind='line', color='green')
plt.xlabel('Age')
plt.ylabel('Duration')
plt.title('Age with Duration')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

#billing amount with age and duration
age_billing_amount = df.groupby('Age')['Billing Amount'].mean()
age_billing_amount.plot(kind='line', color='red')
plt.xlabel('Age')
plt.ylabel('Billing Amount')
plt.title('Age with Billing Amount')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

#Duration with billing amount
duration_billing_amount = df.groupby('Duration')['Billing Amount'].mean()
duration_billing_amount.plot(kind='line', color='purple')
plt.xlabel('Duration')
plt.ylabel('Billing Amount')
plt.title('Duration with Billing Amount')
plt.xticks(rotation=0)
plt.tight_layout()
plt.show()

#Positive correlation shows that the variables are directly related to each other.
#negative correlation shows that the variables are inversely related to each other.


# Perform one-hot encoding for the 'Medical Condition' column
medical_conditions_encoded = pd.get_dummies(df['Medical Condition'])

# Concatenate the one-hot encoded columns with the original DataFrame
df_encoded = pd.concat([df, medical_conditions_encoded], axis=1)

# Calculate the correlation between 'Age' and each medical condition
correlation_with_age = df_encoded[['Age', 'Asthma', 'Cancer', 'Hypertension', 'Arthritis', 'Obesity', 'Diabetes']].corr()

# Extract the correlation between 'Age' and each medical condition
correlation_with_age = correlation_with_age['Age'][1:]

# Print the correlation coefficients
print("Correlation between Age and each medical condition:")
print(correlation_with_age)




# Calculate the correlation matrix
correlation_matrix = df_encoded[['Age', 'Asthma', 'Cancer', 'Hypertension', 'Arthritis', 'Obesity', 'Diabetes']].corr()

# Create a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Correlation Heatmap')
plt.show()

#Drop Doctor
#df = df.drop(['Doctor'], axis=1)

#Drop Hospital
df = df.drop(['Hospital'], axis=1)

#drop admisson date
df = df.drop(['Date of Admission'], axis=1)

#drop discharge date
df = df.drop(['Discharge Date'], axis=1)

#drop inssurance provider
df = df.drop(['Insurance Provider'], axis=1)

#drop name
df = df.drop(['Name'], axis=1)

#first 10 rows
df.head(10)

# Perform one-hot encoding for the 'Gender' feature
gender_encoded = pd.get_dummies(df['Gender'])

# Concatenate the one-hot encoded columns with the original DataFrame
df_encoded = pd.concat([df, gender_encoded], axis=1)

# Drop the original 'Gender' column
df_encoded = df_encoded.drop('Gender', axis=1)

# Print the encoded DataFrame
print(df_encoded)

#encode gender as 1 or 0 male as 1 female as 0
labelencoder = LabelEncoder()
df['Gender'] = labelencoder.fit_transform(df['Gender'])

df.head(10)

#encode bloodtype
labelencoder = LabelEncoder()
df['Blood Type'] = labelencoder.fit_transform(df['Blood Type'])
df.head(30)

#encode medical condiiton as well
labelencoder = LabelEncoder()
df['Medical Condition'] = labelencoder.fit_transform(df['Medical Condition'])
df.head(30)

#medication uniqueu count
df['Medication'].nunique()

#encode medication
labelencoder = LabelEncoder()
df['Medication'] = labelencoder.fit_transform(df['Medication'])
df.head(30)

# Select the columns for the correlation matrix
columns = ['Age', 'Billing Amount', 'Room Number', 'Duration', 'Gender', 'Blood Type', 'Medical Condition', 'Admission Type', 'Medication']

# Calculate the correlation matrix
correlation_matrix = df[columns].corr()

# Create a heatmap
plt.figure(figsize=(8, 6))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', center=0)
plt.title('Correlation Heatmap')
plt.show()

# Create cross-tabulation between 'Admission Type' and 'Gender'
admission_gender_cross = pd.crosstab(index=df['Admission Type'], columns=df['Gender'])

bins = [0, 18, 30, 50, 70, 100]
labels = ['0-17', '18-29', '30-49', '50-69', '70+']
df['Age Group'] = pd.cut(df['Age'], bins=bins, labels=labels)
admission_age_cross = pd.crosstab(index=df['Admission Type'], columns=df['Age Group'])

print("Cross-tabulation between Admission Type and Gender:")
print(admission_gender_cross)
print("\nCross-tabulation between Admission Type and Age Group:")
print(admission_age_cross)

# Create cross-tabulation between 'Medical Condition' and 'Gender'
medical_condition_gender_cross = pd.crosstab(index=df['Medical Condition'], columns=df['Gender'])

# Print cross-tabulation results
print("Cross-tabulation between Medical Condition and Gender:")
print(medical_condition_gender_cross)

# Define age group bins and labels
bins = [18, 30, 50, 70, 100]
labels = ['18-29', '30-49', '50-69', '70+']
df['Age Group'] = pd.cut(df['Age'], bins=bins, labels=labels)

medical_condition_age_cross = pd.crosstab(index=df['Medical Condition'], columns=df['Age Group'], normalize='index')

print("Percentage of each medical condition within different age groups:")
print(medical_condition_age_cross * 100)

medical_conditions = df['Medical Condition']

# Encode medical conditions to numerical values
label_encoder = LabelEncoder()
medical_conditions_encoded = label_encoder.fit_transform(medical_conditions)

# Apply hierarchical clustering
cluster = AgglomerativeClustering(n_clusters=None, distance_threshold=50)
cluster_labels = cluster.fit_predict(medical_conditions_encoded.reshape(-1, 1))

# Add cluster labels back to DataFrame
df['Cluster'] = cluster_labels

# Visualize the clusters
sns.countplot(x='Cluster', data=df)
plt.title('Distribution of Clusters')
plt.show()

# Print the clusters and their associated medical conditions
clustered_conditions = df.groupby('Cluster')['Medical Condition'].unique()
for cluster, conditions in clustered_conditions.items():
    print(f'Cluster {cluster}: {conditions}')

#drop room number
df = df.drop(['Room Number'], axis=1)

#drop billing amount
df = df.drop(['Billing Amount'], axis=1)

#drop age group
df = df.drop(['Age Group'], axis=1)

#drop cluster
df = df.drop(['Cluster'], axis=1)

df.head(20)

# Split the data into features and target variable
X = df.drop(['Test Results'], axis=1)
y = df['Test Results']

# Label encode the target variable
le = LabelEncoder()
y_encoded = le.fit_transform(y)

# Split the data into training and test sets
X_train, X_test, y_train, y_test = train_test_split(X, y_encoded, test_size=0.3, random_state=0)

# Initialize the linear regression model
model = LinearRegression()

# Fit the model to the training data
model.fit(X_train, y_train)

# Predict the target variable for the test set
y_pred = model.predict(X_test)

# Calculate the mean squared error of the model
mse = mean_squared_error(y_test, y_pred)

# Print the mean squared error
print("Mean Squared Error:", mse)


# Calculate Mean Absolute Error (MAE)
mae = mean_absolute_error(y_test, y_pred)
print("Mean Absolute Error:", mae)

# Calculate Root Mean Squared Error (RMSE)
rmse = mean_squared_error(y_test, y_pred, squared=False)
print("Root Mean Squared Error:", rmse)

#Accuracy
accuracy = model.score(X_test, y_test)
print("Accuracy:", accuracy)

#Apply SVM
from sklearn.svm import SVC
svc = SVC()
svc.fit(X_train, y_train)
y_pred = svc.predict(X_test)
accuracy = svc.score(X_test, y_test)
print("Accuracy:", accuracy)

#apply xgboost
import xgboost as xgb
model = xgb.XGBClassifier()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
accuracy = model.score(X_test, y_test)
print("Accuracy:", accuracy)

#apply random forest
from sklearn.ensemble import RandomForestClassifier
model = RandomForestClassifier()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
accuracy = model.score(X_test, y_test)
print("Accuracy:", accuracy)